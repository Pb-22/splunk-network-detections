
# **Scripted or Command Line CertUtil Usage**

This page documents a Splunk detection to identify manual or scripted CertUtil usage for HTTP file downloads. This technique is often associated with **malware staging**, **red team activity**, or **internal testing of controlled services**.

---

## **Why Focus on CertUtil URL Agent**

Typical CertUtil traffic generated by Windows background services (like CRL or OCSP checks) uses the user agent:

```
Microsoft-CryptoAPI/x.x
```

In contrast, when CertUtil is run manually or via script, it often sends a distinct user agent:

```
CertUtil URL Agent
```

This alternate user agent is:

* Not associated with routine system activity
* Frequently tied to manual use or automation
* Common in adversary behavior or internal red team tools

Focusing on this user agent allows threat hunters to find **high-signal, low-noise** events that often indicate **hands-on-keyboard or scripted actions**.

---

## **Do Not Ignore 404 Responses**

Even when the request results in a `404 Not Found`, it may still represent **malicious intent**.

Attackers often use CertUtil to:

* Test whether a target server is reachable
* Confirm that their implant or staging server is responsive
* Trigger benign-looking HTTP requests (e.g., `GET /tttt`) to verify access

> A `404` means the server received the request and responded. It does **not** mean the activity was unsuccessful from the attacker's point of view.

> **Treat 404s as signal, not noise.**

---

## **Detection SPL**

```spl
index=<YOUR_INDEX> sourcetype=<YOUR_SOURCETYPE>  user_agent="CertUtil URL Agent" 
| eval is_short_uri=if(match(uri, "^/[a-zA-Z0-9]{1,6}$"), "yes", "no")
| eval is_risky_extension=if(match(uri, "\.(exe|dll|msi|bat|cmd|ps1|vbs|js|jse|wsf|wsh|hta|scr|com|pif|docm|xlsm|pptm|rtf|one|zip|rar|7z|iso|img|vhd|gz|gzip|lnk|cpl|scf|url)$"), "yes", "no")
| eval is_404_or_403=if(status_code=404 OR status_code=403, "yes", "no")
| eval is_redirect=if(status_code>=300 AND status_code<400, "yes", "no")
| eval is_port_80=if(dest_port=80, "yes", "no")
| eval time=strftime(_time, "%m/%d/%Y%n%H:%M.%Q")
| stats values(url) as url values(status_code) as status_code values(user_agent) as user_agent values(dest_host) as dest_host values(method) as method values(referrer) as referrer values(mime_type) as mime_type values(ja3) as ja3 values(is_short_uri) as short_uri values(is_risky_extension) as risky_ext values(is_404_or_403) as http_error values(is_redirect) as redirected values(is_port_80) as port_80 by host time, src_ip, dest_ip, uid
| sort 0 time
```

---

## **Field Descriptions**

Each `is_*` field in this query adds analytic value and helps with further triage:

| Field                | Description                                                                 |
| -------------------- | --------------------------------------------------------------------------- |
| `is_short_uri`       | Flags short paths like `/tttt`, common in beaconing or staging tools        |
| `is_risky_extension` | Identifies suspicious file types like `.exe`, `.ps1`, `.zip`, etc.          |
| `is_404_or_403`      | Indicates blocked or missing resources that may still be part of C2 testing |
| `is_redirect`        | Detects `3xx` status codes, often used to stage payloads via redirection    |
| `is_port_80`         | Flags use of standard HTTP port â€” helpful to separate from alternate ports  |

---

## **Next Steps**

* **Check inventory and Confluence**: Is this host already known to be a scanner or red team box?
* **Pivot on the `uid`**: Correlate with logs from `file`, `ssl`, `dns`, and `conn` for deeper context.
* **Build a timeline**: Review the behavior of both the client and server within a few hours before and after this activity.

In the timeline, look for:

* File activity: downloads, transfers, writes
* Usernames involved
* Suspicious network connections:

  * All external/public `dest_ip`s
  * Protocols like `SMB`, `DCE_RPC`, `RDP`, `SSH`
  * Uncommon ports
  * Use of IPs instead of domains
  * Uncommon HTTP methods
  * Rare or tool-based user agents

---


